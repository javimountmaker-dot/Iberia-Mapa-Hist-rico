<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Mapa histórico — Rutas MVP</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, sans-serif; }
    .topbar { position:absolute; top:8px; left:8px; right:8px; z-index:999; background:rgba(255,255,245,0.95); border:1px solid #ddd; border-radius:12px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); display:grid; grid-template-columns: 1fr auto auto auto auto; gap:8px; align-items:center; }
    .tools { position:absolute; bottom:8px; left:8px; right:8px; z-index:999; display:grid; gap:8px; }
    .panel { background:rgba(255,255,245,0.95); border:1px solid #ddd; border-radius:12px; padding:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .row > * { margin: 2px 0; }
    label { font-size: 13px; color:#333; }
    input[type=range] { width: 180px; }
    select, button { padding:6px 10px; border-radius:8px; border:1px solid #ccc; background:#fff; }
    button { cursor:pointer; }
    button:active { transform: translateY(1px); }
    .pill { padding:2px 6px; border:1px solid #aaa; border-radius:999px; font-size:12px; background:#fff; }
    .legend { font-size:12px; line-height:1.4; }
    .out { font-size:13px; }
    .stop-label { background:#fff; border:1px solid #aaa; padding:2px 4px; border-radius:6px; font-size:11px; }
  </style>
</head>
<body>
<div id="map"></div>

<div class="topbar panel">
  <div><strong id="title"></strong></div>
  <div class="row">
    <label id="lbl-year"></label>
    <input id="year" type="range" min="201" max="300" value="218" step="1" />
    <span id="year-display">218</span> <span id="era-display"></span>
  </div>
  <div class="row">
    <label id="lbl-lang"></label>
    <select id="lang"><option value="es">ES</option><option value="en">EN</option></select>
  </div>
  <div class="row">
    <label id="lbl-season"></label>
    <select id="season"><option value="summer">summer</option><option value="winter">winter</option></select>
  </div>
  <div class="row">
    <label id="lbl-basemap"></label>
    <select id="basemap"><option value="osm">osm</option><option value="sat">sat</option></select>
  </div>
</div>

<div class="tools">
  <div class="panel legend">
    <div><strong id="legend-title"></strong></div>
    <div><span class="pill" style="background:#cde;border-color:#99c">■</span> <span id="legend-rivers"></span></div>
    <div><span class="pill" style="background:#eee;border-color:#bbb">—</span> <span id="legend-roads"></span></div>
    <div><span class="pill" style="background:#eef;border-color:#aac">≈</span> <span id="legend-coasts"></span></div>
    <div><span class="pill" style="background:#ffe;border-color:#cc9">·</span> <span id="legend-settlements"></span></div>
    <div><span class="pill" style="background:#fde;border-color:#d9a">□</span> <span id="legend-polities"></span></div>
    <div><span class="pill" style="background:#efe;border-color:#9c9">⇢</span> <span id="legend-maritime"></span></div>
  </div>

  <div class="panel out">
    <div class="row">
      <label id="lbl-modes"></label>
      <select id="mode">
        <option value="foot_baggage">foot_baggage</option>
        <option value="foot_double">foot_double</option>
        <option value="foot_forced">foot_forced</option>
        <option value="mountain_pass">mountain_pass</option>
        <option value="trireme">trireme</option>
      </select>
      <label class="pill"><input type="checkbox" id="chk-roads" checked/> <span id="lbl-follow"></span></label>
      <label class="pill"><input type="checkbox" id="chk-auto" checked/> <span id="lbl-auto"></span></label>
    </div>
    <div class="row">
      <button id="btnA">A</button>
      <button id="btnB">B</button>
      <button id="btnCalc">calc</button>
      <button id="btnClear">clear</button>
    </div>
    <div id="summary"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const CONST = { ROMAN_MILE_KM: 1.48, GREEK_STADION_M: 185 };
let i18n = {}; let lang='es';

// Speeds as specified
const SPEEDS = {
  foot_baggage:  { kmh: 23.68/6, hoursPerDay: 6,  breaksPerDay: 0 },
  foot_double:   { kmh: 47.36/12, hoursPerDay: 12, breaksPerDay: 1 },
  foot_forced:   { kmh: 60/10,    hoursPerDay: 10, breaksPerDay: 1 },
  mountain_pass: { kmh: 14.8/5,   hoursPerDay: 5,  breaksPerDay: 0 },
  trireme:       { kmh: 9.26,     hoursPerDay: 12, breaksPerDay: 0 }
};

async function loadJSON(u){ const r=await fetch(u); return r.json(); }
function t(k){ return (i18n[lang] && i18n[lang][k]) || k; }
function updateTexts(){
  document.getElementById('title').innerText = t('app_title');
  document.getElementById('lbl-year').innerText = t('year')+':';
  document.getElementById('era-display').innerText = t('era_bc');
  document.getElementById('lbl-lang').innerText = t('language')+':';
  document.getElementById('lbl-season').innerText = t('season')+':';
  document.getElementById('legend-title').innerText = t('legend');
  document.getElementById('legend-rivers').innerText = t('rivers');
  document.getElementById('legend-roads').innerText = t('roads');
  document.getElementById('legend-polities').innerText = t('polities');
  document.getElementById('legend-coasts').innerText = t('coasts');
  document.getElementById('legend-settlements').innerText = t('settlements');
  document.getElementById('legend-maritime').innerText = t('maritime_routes');
  document.getElementById('lbl-basemap').innerText = t('basemap')+':';
  document.getElementById('basemap').querySelector('option[value="osm"]').textContent = t('osm');
  document.getElementById('basemap').querySelector('option[value="sat"]').textContent = t('sat');
  document.getElementById('lbl-modes').innerText = t('modes')+':';
  const mSel=document.getElementById('mode');
  mSel.querySelector('option[value="foot_baggage"]').textContent=t('foot_baggage');
  mSel.querySelector('option[value="foot_double"]').textContent=t('foot_double');
  mSel.querySelector('option[value="foot_forced"]').textContent=t('foot_forced');
  mSel.querySelector('option[value="mountain_pass"]').textContent=t('mountain_pass');
  mSel.querySelector('option[value="trireme"]').textContent=t('trireme');
  document.getElementById('lbl-follow').innerText = t('follow_roads');
  document.getElementById('lbl-auto').innerText = t('auto_mountain');
  document.getElementById('btnA').textContent = t('pick_A');
  document.getElementById('btnB').textContent = t('pick_B');
  document.getElementById('btnCalc').textContent = t('calculate');
  document.getElementById('btnClear').textContent = t('clear');
}

function bcYear(){ return parseInt(document.getElementById('year').value,10); }
function isActiveByTemporal(p, y){
  const sy = p.start_year||300, se=p.start_era||'BC', ey=p.end_year||201, ee=p.end_era||'BC';
  const startBC = (se==='BC')? sy : 0;
  const endBC = (ee==='BC')? ey : 0;
  return (y <= startBC) && (y >= endBC);
}

function styleFor(feature){
  const p = feature.properties||{};
  if (p.type==='rio') return { color:'#1f78b4', weight:3, opacity:0.9 };
  if (p.type==='costa') return { color:'#3957a6', weight:2, opacity:0.5, dashArray:'4,6' };
  if (p.type==='calzada') return { color:'#6b4e16', weight:2.5 };
  if (p.type==='camino') return { color:'#8a6d3b', weight:2, dashArray:'6,6' };
  if (feature.geometry.type==='Polygon'){
    const tok=p.color_token||'default'; const colors={iberian:'#e7c0a8',default:'#d9d2c6'};
    return { color:'#634b36', weight:1, fillColor:colors[tok]||colors.default, fillOpacity:0.3 };
  }
  return { radius:5, color:'#333', fillColor:'#ffe08a', fillOpacity:0.9 };
}
function pointToLayer(f,ll){ return L.circleMarker(ll, styleFor(f)); }
function onEachFeature(f,layer){
  const p=f.properties||{};
  const tip = `<strong>${p.name||p.id||'—'}</strong><div>${p.alt_names||''}</div>
  <div>${p.culture? p.culture : (p.type||'')}</div>
  <div>${(p.start_year||'?')} ${(p.start_era||'BC')} → ${(p.end_year||'?')} ${(p.end_era||'BC')}</div>
  ${p.source? `<div><em>src:</em> ${p.source}</div>`:''}
  ${p.certainty? `<div><em>incertid.:</em> ${p.certainty}</div>`:''}`;
  layer.bindTooltip(tip);
}

// Map + basemaps
let map = L.map('map', { minZoom:5, maxZoom:12 }).setView([40,-3.5],6);
const basemapOSM = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OpenStreetMap', maxZoom:12 });
const basemapSAT = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{x}/{y}',{ attribution:'Esri, Maxar, Earthstar Geographics, and the GIS User Community', maxZoom:19 });
basemapOSM.addTo(map);

document.getElementById('basemap').addEventListener('change', (e)=>{
  const v=e.target.value;
  if (v==='sat'){ map.removeLayer(basemapOSM); basemapSAT.addTo(map); }
  else { map.removeLayer(basemapSAT); basemapOSM.addTo(map); }
});

let layers={}, allGeojson={}, roadGraph=null;

async function loadLayers(){
  const files = {
    settlements:'data/toponimos.geojson',
    roads:'data/vias.geojson',
    rivers:'data/rios.geojson',
    coasts:'data/costas.geojson',
    polities:'data/politico.geojson',
    ports:'data/puertos.geojson',
    maritime_routes:'data/rutas_maritimas.geojson',
    uncertainty:'data/incertidumbre.geojson'
  };
  for (const [k,u] of Object.entries(files)){
    const gj = await loadJSON(u);
    allGeojson[k]=gj;
    const layer = L.geoJSON(gj,{style:styleFor,pointToLayer,onEachFeature});
    layers[k]=layer;
  }
  layers.rivers.addTo(map);
  layers.roads.addTo(map);
  layers.settlements.addTo(map);
  layers.polities.addTo(map);
}

function refreshVisibility(){
  const y = bcYear();
  for (const [k,layer] of Object.entries(layers)){
    layer.clearLayers();
    const gj = allGeojson[k];
    const filtered = { type:'FeatureCollection', features: (gj.features||[]).filter(f => isActiveByTemporal(f.properties||{}, y)) };
    layer.addData(filtered);
  }
}

// Haversine
function haversine(lat1,lon1,lat2,lon2){
  const toRad = d => d*Math.PI/180, R=6371.0088;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

// Build a road graph carrying segment terrain
function buildRoadGraph(gj){
  const nodes=[], adj=[], segAttr=[]; // adj[i] = [{to, w, terrain}]
  const keyIndex = new Map();
  function key(lon,lat){ return lon.toFixed(6)+','+lat.toFixed(6); }
  function addNode(lon,lat){
    const k=key(lon,lat);
    if (keyIndex.has(k)) return keyIndex.get(k);
    const idx=nodes.length; nodes.push([lat,lon]); keyIndex.set(k,idx); adj[idx]=[]; return idx;
  }
  function addEdge(a,b,w,terrain){
    adj[a].push({to:b,w,terrain}); adj[b].push({to:a,w,terrain});
  }
  for (const f of (gj.features||[])){
    if (!f.geometry || f.geometry.type!=='LineString') continue;
    const terrain = (f.properties && f.properties.terrain) ? f.properties.terrain : 'flat';
    const coords=f.geometry.coordinates;
    for (let i=1;i<coords.length;i++){
      const [lon1,lat1]=coords[i-1], [lon2,lat2]=coords[i];
      const a=addNode(lon1,lat1), b=addNode(lon2,lat2);
      const w=haversine(lat1,lon1,lat2,lon2);
      addEdge(a,b,w,terrain);
    }
  }
  return {nodes, adj};
}

function nearestNodeIdx(graph, lat, lon){
  let best=-1, bestD=1e12;
  for (let i=0;i<graph.nodes.length;i++){
    const [nlat,nlon]=graph.nodes[i];
    const d=haversine(lat,lon,nlat,nlon);
    if (d<bestD){bestD=d;best=i;}
  }
  return best;
}

function dijkstra(graph, s, t){
  const N=graph.nodes.length;
  const dist=new Array(N).fill(Infinity);
  const prev=new Array(N).fill(-1);
  const used=new Array(N).fill(false);
  dist[s]=0;
  for (let it=0; it<N; it++){
    let u=-1, best=Infinity;
    for (let i=0;i<N;i++){ if(!used[i] && dist[i]<best){ best=dist[i]; u=i; } }
    if (u===-1) break;
    if (u===t) break;
    used[u]=true;
    for (const e of graph.adj[u]){
      const alt=dist[u]+e.w;
      if (alt<dist[e.to]){ dist[e.to]=alt; prev[e.to]=u; }
    }
  }
  if (dist[t]===Infinity) return null;
  const path=[]; let u=t;
  while (u!==-1){ path.push(u); u=prev[u]; }
  path.reverse();
  return path;
}

function routeViaRoads(graph, A, B){
  if (!graph || !graph.nodes.length) return null;
  const idxA = graph.nodes.length; const idxB = graph.nodes.length+1;
  const nodes = graph.nodes.slice(); const adj = graph.adj.map(a=>a.slice());
  nodes.push([A.lat,A.lng]); adj[idxA]=[];
  nodes.push([B.lat,B.lng]); adj[idxB]=[];
  // connect to nearest existing nodes
  const nA = nearestNodeIdx(graph, A.lat, A.lng);
  const nB = nearestNodeIdx(graph, B.lat, B.lng);
  function connect(u,v){
    const d=haversine(nodes[u][0],nodes[u][1],nodes[v][0],nodes[v][1]);
    // inherit 'flat' for virtual connectors
    adj[u].push({to:v,w:d,terrain:'flat'}); adj[v].push({to:u,w:d,terrain:'flat'});
  }
  if (nA>=0) connect(idxA, nA);
  if (nB>=0) connect(idxB, nB);
  const p = dijkstra({nodes,adj}, idxA, idxB);
  if (!p) return null;
  // Build coords + segment terrain
  const coords=[]; const segs=[];
  for (let i=1;i<p.length;i++){
    const u=p[i-1], v=p[i];
    const Axy = nodes[u], Bxy = nodes[v];
    coords.push([Axy[0],Axy[1]]);
    // find the edge in adj[u] matching v to read terrain
    const e = adj[u].find(e=>e.to===v) || {terrain:'flat', w:haversine(Axy[0],Axy[1],Bxy[0],Bxy[1])};
    segs.push({from:[Axy[0],Axy[1]], to:[Bxy[0],Bxy[1]], km:e.w, terrain:e.terrain});
  }
  coords.push([nodes[p[p.length-1]][0], nodes[p[p.length-1]][1]]);
  return { coords, segs };
}

function routeStraight(A,B){
  return { coords: [[A.lat,A.lng],[B.lat,B.lng]], segs: [{from:[A.lat,A.lng], to:[B.lat,B.lng], km: haversine(A.lat,A.lng,B.lat,B.lng), terrain:'flat'}] };
}

// Place stops by TIME (hours), not distance
function interpolate(A, B, t){
  return [ A[0] + t*(B[0]-A[0]), A[1] + t*(B[1]-A[1]) ];
}
function placeStopsByTime(segs, hoursPerDay, kmhForTerrain){
  let hoursAcc = 0.0;
  let nextStopAt = hoursPerDay;
  const stops = [];
  for (const s of segs){
    const kmh = kmhForTerrain(s.terrain);
    const segHours = s.km / kmh;
    while (hoursAcc + segHours >= nextStopAt - 1e-9){
      const need = nextStopAt - hoursAcc;
      const t = need / segHours;
      const pt = interpolate(s.from, s.to, t);
      stops.push(pt);
      // advance target to next day stop
      nextStopAt += hoursPerDay;
    }
    hoursAcc += segHours;
  }
  return stops;
}
function placeMidBreaksByTime(segs, hoursPerDay, breaksPerDay, kmhForTerrain){
  if (breaksPerDay<=0) return [];
  const breaks=[];
  let hoursAcc=0.0;
  // targets at fractions of each day: hoursPerDay/(breaks+1), then +hoursPerDay each day
  let k=1; 
  let nextBreakAt = hoursPerDay * (1/(breaksPerDay+1));
  while (True){
    // Attempt to place until we exceed total route hours
    // First compute total hours quickly
    break;
  }
}

function totalHours(segs, kmhForTerrain){
  let H=0; for (const s of segs){ H += s.km / kmhForTerrain(s.terrain); } return H;
}

// Globals for UI
let roadGraph=null, layers={}, allGeojson={};
let picking='', A=null, B=null;
let markerA=null, markerB=null, routeLayer=null, nightStopsLayer=null, breakStopsLayer=null;

function showRoute(route, mode, autoMountain){
  if (routeLayer){ map.removeLayer(routeLayer); routeLayer=null; }
  routeLayer = L.polyline(route.coords, { color:'#333', weight:3 }).addTo(map);
  map.fitBounds(routeLayer.getBounds(), { padding:[30,30] });

  // Speed resolver by terrain
  const season = document.getElementById('season').value;
  function kmhForTerrain(terrain){
    // If trireme, ignore terrain
    if (mode==='trireme'){
      let v = SPEEDS.trireme.kmh;
      if (season==='winter') v*=0.85;
      return v;
    }
    // Land modes
    const base = SPEEDS[mode];
    if (autoMountain && terrain==='mountain'){
      return SPEEDS.mountain_pass.kmh; // mountain pass speed
    }
    return base.kmh;
  }
  function hoursPerDayForTerrain(terrain){
    if (mode==='trireme') return SPEEDS.trireme.hoursPerDay;
    if (autoMountain && terrain==='mountain') return SPEEDS.mountain_pass.hoursPerDay;
    return SPEEDS[mode].hoursPerDay;
  }
  const kmTotal = route.segs.reduce((a,s)=>a+s.km,0);
  const roman = kmTotal / CONST.ROMAN_MILE_KM;
  const stadia = (kmTotal*1000) / CONST.GREEK_STADION_M;

  const H = totalHours(route.segs, kmhForTerrain);
  // We choose a representative hoursPerDay as: hoursPerDay of the dominant mode in each segment
  // For placing nightly stops robustly, we will use piecewise time accumulation with the *current* segment hoursPerDay,
  // but because hoursPerDay can vary by terrain, we place stops at absolute hours: e.g., at 6h, 12h, 18h, ... of cumulative moving time.
  // We'll use base mode's hoursPerDay for the schedule grid, but if it's mountain terrain and auto is on, we'll switch to mountain day's length for that time window.
  // For simplicity, define day length as hoursPerDay of the *current* segment when crossing a day boundary.
  // Implementation: Use a constant day length = base mode's hoursPerDay; this is a reasonable MVP simplification.
  const baseHPD = (mode==='trireme') ? SPEEDS.trireme.hoursPerDay : SPEEDS[mode].hoursPerDay;
  const nightStops = placeStopsByTime(route.segs, baseHPD, kmhForTerrain);

  // Midday breaks positions: evenly split each day; we map them on absolute hour scale too.
  const breaksPerDay = (mode==='trireme') ? 0 : SPEEDS[mode].breaksPerDay;
  const midBreaks = []; 
  if (breaksPerDay>0){
    // place at fractions within each day window
    const totalH = H;
    const dayCount = Math.ceil(totalH / baseHPD);
    // We'll walk along segs and add markers at hours baseHPD*(d + j/(breaks+1))
    const targets = [];
    for (let d=0; d<dayCount; d++){
      for (let j=1; j<=breaksPerDay; j++){
        targets.push(d*baseHPD + (j*(baseHPD/(breaksPerDay+1))));
      }
    }
    let hAcc=0.0; let tIdx=0;
    for (const s of route.segs){
      const v = kmhForTerrain(s.terrain);
      const segH = s.km / v;
      while (tIdx < targets.length and hAcc + segH >= targets[tIdx] - 1e-9){
        const need = targets[tIdx] - hAcc;
        const tt = need / segH;
        const pt = interpolate(s.from, s.to, tt);
        midBreaks.push(pt);
        tIdx += 1;
      }
      hAcc += segH;
      if (tIdx>=targets.length) break;
    }
  }

  // Draw stops
  if (nightStopsLayer){ map.removeLayer(nightStopsLayer); nightStopsLayer=null; }
  nightStopsLayer = L.layerGroup();
  nightStops.forEach((p,i)=>{
    L.circleMarker([p[0],p[1]], { radius:5, color:'#b00', fillColor:'#e33', fillOpacity:0.9 })
      .bindTooltip(`<span class="stop-label">${t('night_stops')} #${i+1}</span>`)
      .addTo(nightStopsLayer);
  });
  nightStopsLayer.addTo(map);

  if (breakStopsLayer){ map.removeLayer(breakStopsLayer); breakStopsLayer=null; }
  breakStopsLayer = L.layerGroup();
  midBreaks.forEach((p,i)=>{
    L.circleMarker([p[0],p[1]], { radius:4, color:'#cc9a00', fillColor:'#ffd000', fillOpacity:0.9 })
      .bindTooltip(`<span class="stop-label">${t('mid_breaks')} #${i+1}</span>`)
      .addTo(breakStopsLayer);
  });
  breakStopsLayer.addTo(map);

  const days = Math.floor(H / baseHPD);
  const hours = Math.round(H - days*baseHPD);
  const restNights = Math.max(0, Math.ceil(H / baseHPD) - 1);

  document.getElementById('summary').innerHTML = `
    <div><strong>${t('distance')}:</strong> ${kmTotal.toFixed(2)} km · ${roman.toFixed(2)} ${t('roman_miles')} · ${Math.round(stadia)} ${t('greek_stadia')}</div>
    <div><strong>${t('time_estimate')}:</strong> ${days} d + ${hours} h — ${t('rest_nights')}: ${restNights} · ${t('day_breaks')}: ${breaksPerDay||0}/día</div>
  `;
}

function styleForRouteSeg(terrain){
  if (terrain==='mountain') return { color:'#a33', weight:4, dashArray:'6,4' };
  return { color:'#333', weight:3 };
}

let layersRouteSeg=null;
function drawRouteSegments(route){
  if (layersRouteSeg){ map.removeLayer(layersRouteSeg); layersRouteSeg=null; }
  layersRouteSeg = L.layerGroup();
  for (const s of route.segs){
    L.polyline([s.from, s.to], styleForRouteSeg(s.terrain)).addTo(layersRouteSeg);
  }
  layersRouteSeg.addTo(map);
}

function setupUI(){
  const year = document.getElementById('year');
  const yd = document.getElementById('year-display');
  yd.innerText = year.value;
  year.addEventListener('input', ()=>{ yd.innerText=year.value; refreshVisibility(); });

  document.getElementById('lang').addEventListener('change', (e)=>{ lang=e.target.value; updateTexts(); });

  document.getElementById('btnA').addEventListener('click', ()=> setPicking('A'));
  document.getElementById('btnB').addEventListener('click', ()=> setPicking('B'));
  document.getElementById('btnClear').addEventListener('click', clearAll);
  document.getElementById('btnCalc').addEventListener('click', ()=>{
    if (!A || !B){ alert('Selecciona A y B'); return; }
    const mode = document.getElementById('mode').value;
    const follow = document.getElementById('chk-roads').checked;
    const autoMountain = document.getElementById('chk-auto').checked;
    let route=null;
    if (follow){
      route = routeViaRoads(roadGraph, A, B);
      if (!route){ route = routeStraight(A,B); }
    } else {
      route = routeStraight(A,B);
    }
    // Visualize per-terrain segments
    drawRouteSegments(route);
    showRoute(route, mode, autoMountain);
  });

  map.on('click', (e)=>{
    if (!picking) return;
    if (picking==='A'){
      A = { lat:e.latlng.lat, lng:e.latlng.lng };
      if (markerA) map.removeLayer(markerA);
      markerA = L.marker([A.lat,A.lng]).addTo(map).bindTooltip(t('a_marker')).openTooltip();
      picking=''; map.getContainer().style.cursor='';
    } else if (picking==='B'){
      B = { lat:e.latlng.lat, lng:e.latlng.lng };
      if (markerB) map.removeLayer(markerB);
      markerB = L.marker([B.lat,B.lng]).addTo(map).bindTooltip(t('b_marker')).openTooltip();
      picking=''; map.getContainer().style.cursor='';
    }
  });
}

function setPicking(which){
  picking=which;
  map.getContainer().style.cursor='crosshair';
  alert(t('tip_pick') + ': ' + (which==='A'? t('a_marker') : t('b_marker')));
}

function clearAll(){
  picking='';
  if (markerA){ map.removeLayer(markerA); markerA=null; }
  if (markerB){ map.removeLayer(markerB); markerB=null; }
  if (routeLayer){ map.removeLayer(routeLayer); routeLayer=null; }
  if (nightStopsLayer){ map.removeLayer(nightStopsLayer); nightStopsLayer=null; }
  if (breakStopsLayer){ map.removeLayer(breakStopsLayer); breakStopsLayer=null; }
  if (layersRouteSeg){ map.removeLayer(layersRouteSeg); layersRouteSeg=null; }
  A=B=null; document.getElementById('summary').innerHTML='';
  map.getContainer().style.cursor='';
}

(async function init(){
  i18n.es = await loadJSON('i18n/es.json');
  i18n.en = await loadJSON('i18n/en.json');
  updateTexts();
  await loadLayers();
  refreshVisibility();
  roadGraph = buildRoadGraph(allGeojson.roads);
  setupUI();
})();
</script>
</body>
</html>
